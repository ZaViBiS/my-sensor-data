<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
    <title>Sensor Data Viewer</title>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-adapter-date-fns"></script>
    <style>
      body {
        font-family: Arial, sans-serif;
        background-color: #1a1a1a;
        color: #e0e0e0;
        padding: 20px;
      }
      #chartContainer {
        background-color: #2a2a2a;
        padding: 20px;
        border-radius: 8px;
        box-shadow: 0 2px 4px rgba(0, 0, 0, 0.5);
      }
      canvas {
        width: 100% !important;
        height: auto !important;
        max-height: 400px;
      }
      #latestData {
        margin-top: 20px;
        padding: 15px;
        background-color: #2a2a2a;
        border-radius: 8px;
        text-align: center;
      }
      .label {
        font-weight: bold;
        color: #fff;
      }
      .temp { color: #FF6384; }
      .hum { color: #36A2EB; }
      .vpd { color: #FFCE56; }
      .fan { color: #4BC0C0; }
      .time { color: #e0e0e0; }
      /* Toggle Switch Styles */
      .toggle-container {
        text-align: center;
        margin-bottom: 20px;
      }
      .toggle-label {
        font-size: 16px;
        margin-right: 10px;
        vertical-align: middle;
      }
      .toggle-switch {
        position: relative;
        display: inline-block;
        width: 50px;
        height: 24px;
        vertical-align: middle;
      }
      .toggle-switch input {
        opacity: 0;
        width: 0;
        height: 0;
      }
      .slider {
        position: absolute;
        cursor: pointer;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        background-color: #ccc;
        transition: 0.4s;
        border-radius: 24px;
      }
      .slider:before {
        position: absolute;
        content: "";
        height: 18px;
        width: 18px;
        left: 3px;
        bottom: 3px;
        background-color: white;
        transition: 0.4s;
        border-radius: 50%;
      }
      input:checked + .slider {
        background-color: #4BC0C0;
      }
      input:checked + .slider:before {
        transform: translateX(26px);
      }
    </style>
  </head>
  <body>
    <h1 style="text-align:center;">Sensor Data Viewer</h1>
    <div class="toggle-container">
      <label class="toggle-label" for="gapToggle">Show Gaps for Missing Data</label>
      <label class="toggle-switch">
        <input type="checkbox" id="gapToggle" checked>
        <span class="slider"></span>
      </label>
    </div>
    <div id="chartContainer">
      <canvas id="sensorChart"></canvas>
    </div>
    <div id="latestData">
      <p><span class="label">Latest Temperature:</span> <span class="temp" id="latestTemp">--</span></p>
      <p><span class="label">Average Temperature (24h):</span> <span class="temp" id="avgTemp">--</span></p>
      <p><span class="label">Latest Humidity:</span> <span class="hum" id="latestHum">--</span></p>
      <p><span class="label">Average Humidity (24h):</span> <span class="hum" id="avgHum">--</span></p>
      <p><span class="label">Latest VPD:</span> <span class="vpd" id="latestVpd">--</span></p>
      <p><span class="label">Average VPD (24h):</span> <span class="vpd" id="avgVpd">--</span></p>
      <p><span class="label">Latest Fan Speed:</span> <span class="fan" id="latestFan">--</span></p>
      <p><span class="label">Average Fan Speed (24h):</span> <span class="fan" id="avgFan">--</span></p>
      <p><span class="label">Time Since Last Update:</span> <span class="time" id="timeSince">--</span></p>
    </div>

    <script>
      let latestTimestampSec = null;
      let showGaps = true; // Default: show gaps
      const ctx = document.getElementById("sensorChart").getContext("2d");
      const sensorChart = new Chart(ctx, {
        type: "line",
        data: {
          labels: [],
          datasets: [
            {
              label: "Temperature (°C)",
              data: [],
              borderColor: "#FF6384",
              yAxisID: "y-temp",
              fill: false,
              pointRadius: 0,
              spanGaps: false
            },
            {
              label: "Avg Temperature (24h)",
              data: [],
              borderColor: "#FF6384",
              borderDash: [5, 5],
              yAxisID: "y-temp",
              fill: false,
              pointRadius: 0,
              spanGaps: false
            },
            {
              label: "Humidity (%)",
              data: [],
              borderColor: "#36A2EB",
              yAxisID: "y-hum",
              fill: false,
              pointRadius: 0,
              spanGaps: false
            },
            {
              label: "Avg Humidity (24h)",
              data: [],
              borderColor: "#36A2EB",
              borderDash: [5, 5],
              yAxisID: "y-hum",
              fill: false,
              pointRadius: 0,
              spanGaps: false
            },
            {
              label: "VPD (kPa)",
              data: [],
              borderColor: "#FFCE56",
              yAxisID: "y-vpd",
              fill: false,
              pointRadius: 0,
              spanGaps: false
            },
            {
              label: "Avg VPD (24h)",
              data: [],
              borderColor: "#FFCE56",
              borderDash: [5, 5],
              yAxisID: "y-vpd",
              fill: false,
              pointRadius: 0,
              spanGaps: false
            },
            {
              label: "Fan Speed",
              data: [],
              borderColor: "#4BC0C0",
              yAxisID: "y-fan",
              fill: false,
              pointRadius: 0,
              spanGaps: false
            },
            {
              label: "Avg Fan Speed (24h)",
              data: [],
              borderColor: "#4BC0C0",
              borderDash: [5, 5],
              yAxisID: "y-fan",
              fill: false,
              pointRadius: 0,
              spanGaps: false
            },
          ]
        },
        options: {
          responsive: true,
          interaction: {
            mode: "index",
            intersect: false,
          },
          scales: {
            x: {
              type: "time",
              time: {
                unit: "second",
                stepSize: 20,
                tooltipFormat: "HH:mm:ss",
                displayFormats: {
                  second: "HH:mm:ss"
                }
              },
              ticks: { color: "#e0e0e0" },
              title: {
                display: true,
                text: "Time",
                color: "#e0e0e0"
              }
            },
            "y-temp": {
              type: "linear",
              position: "left",
              title: {
                display: true,
                text: "Temperature",
                color: "#FF6384"
              },
              ticks: { color: "#FF6384" }
            },
            "y-hum": {
              type: "linear",
              position: "right",
              title: {
                display: true,
                text: "Humidity",
                color: "#36A2EB"
              },
              ticks: { color: "#36A2EB" }
            },
            "y-vpd": {
              type: "linear",
              position: "left",
              title: {
                display: true,
                text: "VPD",
                color: "#FFCE56"
              },
              ticks: { color: "#FFCE56" }
            },
            "y-fan": {
              type: "linear",
              position: "right",
              title: {
                display: true,
                text: "Fan",
                color: "#4BC0C0"
              },
              ticks: { color: "#4BC0C0" }
            },
          },
          plugins: {
            legend: {
              labels: {
                color: "#e0e0e0"
              }
            }
          }
        }
      });

      function formatTimeElapsed(timestampSec) {
        const timestampMs = parseInt(timestampSec) * 1000;
        const now = Date.now();
        const diffSeconds = Math.floor((now - timestampMs) / 1000);
        if (diffSeconds < 0) return 'In the future';
        if (diffSeconds < 60) return `${diffSeconds} sec ago`;
        const minutes = Math.floor(diffSeconds / 60);
        if (minutes < 60) return `${minutes} min ago`;
        const hours = Math.floor(minutes / 60);
        if (hours < 24) return `${hours} hr ago`;
        const days = Math.floor(hours / 24);
        return `${days} day${days === 1 ? '' : 's'} ago`;
      }

      async function fetchData() {
        try {
          const response = await fetch("https://data.ygryk.de", {
            method: "GET",
            headers: { "Content-Type": "application/json" }
          });

          if (!response.ok) {
            throw new Error(`HTTP error! Status: ${response.status}`);
          }

          const data = await response.json();
          if (!Array.isArray(data) || data.length === 0) {
            throw new Error("Expected non-empty array of entries");
          }

          const hasValidStructure = data.every(entry =>
            typeof entry === 'object' &&
            'time' in entry &&
            Number.isFinite(entry.time)
          );
          if (!hasValidStructure) {
            throw new Error("Invalid data structure: missing or invalid 'time' property");
          }

          data.sort((a, b) => a.time - b.time);
          const latest = data[data.length - 1] || {};

          // Process data based on showGaps
          let processedData;
          if (showGaps) {
            // Show gaps: insert null points for missing intervals
            processedData = [];
            const intervalSec = 20;
            const toleranceSec = 2;
            for (let i = 0; i < data.length; i++) {
              processedData.push(data[i]);
              if (i < data.length - 1) {
                const currentTime = data[i].time;
                const nextTime = data[i + 1].time;
                const timeDiff = nextTime - currentTime;
                if (timeDiff > intervalSec + toleranceSec) {
                  const numMissing = Math.floor((timeDiff - intervalSec) / intervalSec);
                  for (let j = 1; j <= numMissing; j++) {
                    const missingTime = currentTime + j * intervalSec;
                    processedData.push({
                      time: missingTime,
                      temp: null,
                      hum: null,
                      vpd: null,
                      fan_speed: null
                    });
                  }
                }
              }
            }
            processedData.sort((a, b) => a.time - b.time);
          } else {
            // Hide gaps: normalize timestamps to regular 20-second intervals
            processedData = [];
            const intervalSec = 20;
            const startTime = data[0].time;
            data.forEach((entry, index) => {
              processedData.push({
                time: startTime + index * intervalSec,
                temp: entry.temp,
                hum: entry.hum,
                vpd: entry.vpd,
                fan_speed: entry.fan_speed
              });
            });
          }

          const tempData = [];
          const humData = [];
          const vpdData = [];
          const fanData = [];

          let tempSum = 0, tempCount = 0;
          let humSum = 0, humCount = 0;
          let vpdSum = 0, vpdCount = 0;
          let fanSum = 0, fanCount = 0;

          processedData.forEach(entry => {
            const timestampMs = entry.time * 1000;
            tempData.push({ x: timestampMs, y: entry.temp ?? null });
            humData.push({ x: timestampMs, y: entry.hum ?? null });
            vpdData.push({ x: timestampMs, y: entry.vpd ?? null });
            fanData.push({ x: timestampMs, y: entry.fan_speed ?? null });

            if (entry.temp != null && !isNaN(entry.temp)) { tempSum += entry.temp; tempCount++; }
            if (entry.hum != null && !isNaN(entry.hum)) { humSum += entry.hum; humCount++; }
            if (entry.vpd != null && !isNaN(entry.vpd)) { vpdSum += entry.vpd; vpdCount++; }
            if (entry.fan_speed != null && !isNaN(entry.fan_speed)) { fanSum += entry.fan_speed; fanCount++; }
          });

          const avgTemp = tempCount > 0 ? tempSum / tempCount : null;
          const avgHum = humCount > 0 ? humSum / humCount : null;
          const avgVpd = vpdCount > 0 ? vpdSum / vpdCount : null;
          const avgFan = fanCount > 0 ? fanSum / fanCount : null;

          const avgTempData = processedData.map(entry => ({ x: entry.time * 1000, y: avgTemp }));
          const avgHumData = processedData.map(entry => ({ x: entry.time * 1000, y: avgHum }));
          const avgVpdData = processedData.map(entry => ({ x: entry.time * 1000, y: avgVpd }));
          const avgFanData = processedData.map(entry => ({ x: entry.time * 1000, y: avgFan }));

          // Update spanGaps based on showGaps
          sensorChart.data.datasets.forEach(dataset => {
            dataset.spanGaps = !showGaps;
          });

          sensorChart.data.datasets[0].data = tempData;
          sensorChart.data.datasets[1].data = avgTempData;
          sensorChart.data.datasets[2].data = humData;
          sensorChart.data.datasets[3].data = avgHumData;
          sensorChart.data.datasets[4].data = vpdData;
          sensorChart.data.datasets[5].data = avgVpdData;
          sensorChart.data.datasets[6].data = fanData;
          sensorChart.data.datasets[7].data = avgFanData;
          sensorChart.update();

          document.getElementById("latestTemp").textContent = latest.temp != null ? latest.temp.toFixed(1) + " °C" : "--";
          document.getElementById("avgTemp").textContent = avgTemp != null ? avgTemp.toFixed(1) + " °C" : "--";
          document.getElementById("latestHum").textContent = latest.hum != null ? latest.hum.toFixed(1) + " %" : "--";
          document.getElementById("avgHum").textContent = avgHum != null ? avgHum.toFixed(1) + " %" : "--";
          document.getElementById("latestVpd").textContent = latest.vpd != null ? latest.vpd.toFixed(2) + " kPa" : "--";
          document.getElementById("avgVpd").textContent = avgVpd != null ? avgVpd.toFixed(2) + " kPa" : "--";
          document.getElementById("latestFan").textContent = latest.fan_speed != null ? latest.fan_speed.toFixed(0) : "--";
          document.getElementById("avgFan").textContent = avgFan != null ? avgFan.toFixed(0) : "--";
          latestTimestampSec = latest.time || null;
          document.getElementById("timeSince").textContent = latestTimestampSec ? formatTimeElapsed(latestTimestampSec) : "--";
        } catch (err) {
          console.error("Fetch data error:", err.message);
          document.getElementById("latestTemp").textContent = "--";
          document.getElementById("avgTemp").textContent = "--";
          document.getElementById("latestHum").textContent = "--";
          document.getElementById("avgHum").textContent = "--";
          document.getElementById("latestVpd").textContent = "--";
          document.getElementById("avgVpd").textContent = "--";
          document.getElementById("latestFan").textContent = "--";
          document.getElementById("avgFan").textContent = "--";
          document.getElementById("timeSince").textContent = "--";
        }
      }

      // Toggle event listener
      document.getElementById("gapToggle").addEventListener("change", (event) => {
        showGaps = event.target.checked;
        fetchData(); // Refresh chart with new gap settings
      });

      fetchData();
      setInterval(fetchData, 20000);
      setInterval(() => {
        if (latestTimestampSec !== null) {
          document.getElementById("timeSince").textContent = formatTimeElapsed(latestTimestampSec);
        }
      }, 500);
    </script>
    <script>(function(){function c(){var b=a.contentDocument||a.contentWindow.document;if(b){var d=b.createElement('script');d.innerHTML="window.__CF$cv$params={r:'93aaecb54a5eb0ee',t:'MTc0NjM5MjM5NS4wMDAwMDA='};var a=document.createElement('script');a.nonce='';a.src='/cdn-cgi/challenge-platform/scripts/jsd/main.js';document.getElementsByTagName('head')[0].appendChild(a);";b.getElementsByTagName('head')[0].appendChild(d)}}if(document.body){var a=document.createElement('iframe');a.height=1;a.width=1;a.style.position='absolute';a.style.top=0;a.style.left=0;a.style.border='none';a.style.visibility='hidden';document.body.appendChild(a);if('loading'!==document.readyState)c();else if(window.addEventListener)document.addEventListener('DOMContentLoaded',c);else{var e=document.onreadystatechange||function(){};document.onreadystatechange=function(b){e(b);'loading'!==document.readyState&&(document.onreadystatechange=e,c())}}}})();</script>
  </body>
</html>
