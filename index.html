<script type="text/javascript">
        var gk_isXlsx = false;
        var gk_xlsxFileLookup = {};
        var gk_fileData = {};
        function filledCell(cell) {
          return cell !== '' && cell != null;
        }
        function loadFileData(filename) {
        if (gk_isXlsx && gk_xlsxFileLookup[filename]) {
            try {
                var workbook = XLSX.read(gk_fileData[filename], { type: 'base64' });
                var firstSheetName = workbook.SheetNames[0];
                var worksheet = workbook.Sheets[firstSheetName];

                // Convert sheet to JSON to filter blank rows
                var jsonData = XLSX.utils.sheet_to_json(worksheet, { header: 1, blankrows: false, defval: '' });
                // Filter out blank rows (rows where all cells are empty, null, or undefined)
                var filteredData = jsonData.filter(row => row.some(filledCell));

                // Heuristic to find the header row by ignoring rows with fewer filled cells than the next row
                var headerRowIndex = filteredData.findIndex((row, index) =>
                  row.filter(filledCell).length >= filteredData[index + 1]?.filter(filledCell).length
                );
                // Fallback
                if (headerRowIndex === -1 || headerRowIndex > 25) {
                  headerRowIndex = 0;
                }

                // Convert filtered JSON back to CSV
                var csv = XLSX.utils.aoa_to_sheet(filteredData.slice(headerRowIndex)); // Create a new sheet from filtered array of arrays
                csv = XLSX.utils.sheet_to_csv(csv, { header: 1 });
                return csv;
            } catch (e) {
                console.error(e);
                return "";
            }
        }
        return gk_fileData[filename] || "";
        }
        </script><!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>JSON Data Visualization</title>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <style>
      body {
        font-family: Arial, sans-serif;
        margin: 0;
        padding: 20px;
        background-color: #1a1a1a; /* Темний фон */
        color: #e0e0e0; /* Світлий текст */
        box-sizing: border-box;
      }
      h1 {
        font-size: 1.5rem; /* Базовий розмір заголовка */
        text-align: center;
        margin-bottom: 20px;
        color: #ffffff; /* Білий заголовок */
      }
      #chartContainer {
        width: 100%;
        margin: 0 auto;
        padding: 0;
        position: relative;
        max-width: 100%;
        overflow-x: auto; /* Горизонтальна прокрутка для малих екранів */
        background-color: #2a2a2a; /* Темний фон контейнера графіка */
        border-radius: 8px;
        box-shadow: 0 2px 4px rgba(0, 0, 0, 0.5); /* Тінь */
      }
      canvas {
        width: 100% !important; /* Графік займає всю ширину */
        height: auto !important; /* Адаптивна висота */
        max-height: 400px; /* Максимальна висота для десктопів */
      }
      #errorMessage {
        display: none;
        color: #ff6384;
        text-align: center;
        margin-top: 10px;
        font-size: 1rem;
      }
      /* Адаптація для телефонів (екрани до 768px) */
      @media (max-width: 768px) {
        h1 {
          font-size: 1.2rem; /* Менший заголовок */
        }
        #chartContainer {
          padding: 0 5px; /* Легкий відступ */
        }
        canvas {
          max-height: 300px; /* Зменшена висота графіка */
        }
      }
      /* Для дуже маленьких екранів (до 480px) */
      @media (max-width: 480px) {
        h1 {
          font-size: 1rem; /* Ще менший заголовок */
        }
        canvas {
          max-height: 250px; /* Ще менша висота */
        }
      }
    </style>
  </head>
  <body>
    <h1>JSON Data Visualization</h1>
    <div id="chartContainer">
      <canvas id="sensorChart"></canvas>
    </div>
    <div id="errorMessage"></div>

    <script>
      // Налаштування графіка
      const ctx = document.getElementById("sensorChart").getContext("2d");
      const sensorChart = new Chart(ctx, {
        type: "line",
        data: {
          labels: [],
          datasets: [
            {
              label: "Temperature",
              data: [],
              borderColor: "#FF6384" /* Червоний для температури */,
              fill: true,
              yAxisID: "y-temp",
              pointRadius: 0,
            },
            {
              label: "Humidity",
              data: [],
              borderColor: "#36A2EB" /* Синій для вологості */,
              fill: true,
              yAxisID: "y-hum",
              pointRadius: 0,
            },
            {
              label: "VPD",
              data: [],
              borderColor: "#FFCE56" /* Жовтий для VPD */,
              fill: true,
              yAxisID: "y-vpd",
              pointRadius: 0,
            },
            {
              label: "Fan Speed",
              data: [],
              borderColor: "#4BC0C0" /* Бірюзовий для вентилятора */,
              fill: true,
              yAxisID: "y-fan",
              pointRadius: 0,
            },
          ],
        },
        options: {
          responsive: true,
          maintainAspectRatio: false,
          interaction: {
            mode: "index",
            intersect: false,
          },
          scales: {
            x: {
              title: {
                display: true,
                text: "Time",
                color: "#e0e0e0",
              },
              ticks: {
                color: "#e0e0e0",
              },
            },
            "y-temp": {
              type: "linear",
              position: "left",
              title: {
                display: true,
                text: "Temperature (°C)",
                color: "#FF6384",
              },
              ticks: {
                color: "#FF6384",
              },
              grid: {
                color: "#404040",
              },
            },
            "y-hum": {
              type: "linear",
              position: "right",
              title: {
                display: true,
                text: "Humidity (%)",
                color: "#36A2EB",
              },
              ticks: {
                color: "#36A2EB",
              },
              grid: {
                drawOnChartArea: false,
              },
            },
            "y-vpd": {
              type: "linear",
              position: "left",
              title: {
                display: true,
                text: "VPD (kPa)",
                color: "#FFCE56",
              },
              ticks: {
                color: "#FFCE56",
              },
              grid: {
                drawOnChartArea: false,
              },
            },
            "y-fan": {
              type: "linear",
              position: "right",
              title: {
                display: true,
                text: "Fan Speed",
                color: "#4BC0C0",
              },
              ticks: {
                color: "#4BC0C0",
              },
              grid: {
                drawOnChartArea: false,
              },
            },
          },
          plugins: {
            legend: {
              labels: {
                color: "#e0e0e0",
              },
            },
          },
        },
      });

      // Функція для обчислення динамічного діапазону
      function calculateAxisRange(data) {
        if (!data || data.length === 0) {
          return { min: 0, max: 100 };
        }
        const min = Math.min(...data);
        const max = Math.max(...data);
        const range = max - min;
        const padding = range * 0.1 || 1;
        return {
          min: min - padding,
          max: max + padding,
        };
      }

      // Функція для відображення повідомлення про помилку
      function showError(message) {
        const errorDiv = document.getElementById("errorMessage");
        errorDiv.textContent = message;
        errorDiv.style.display = "block";
      }

      // Функція для приховання повідомлення про помилку
      function hideError() {
        const errorDiv = document.getElementById("errorMessage");
        errorDiv.textContent = "";
        errorDiv.style.display = "none";
      }

      // Отримання даних з data.ygryk.de
      async function fetchData() {
        try {
          const response = await fetch("https://data.ygryk.de", {
            method: "GET",
            headers: {
              "Content-Type": "application/json",
            },
          });

          if (!response.ok) {
            throw new Error(`HTTP error! Status: ${response.status}`);
          }

          const data = await response.json();
          if (!data || Object.keys(data).length === 0) {
            throw new Error("No data received from server");
          }

          const labels = [];
          const tempData = [];
          const humData = [];
          const vpdData = [];
          const fanData = [];

          // Обробка даних
          Object.entries(data).forEach(([timestamp, entry]) => {
            if (!entry || typeof entry !== "object") {
              console.warn(`Invalid entry at timestamp ${timestamp}`);
              return;
            }
            const time = new Date(parseInt(timestamp) * 1000);
            labels.push(time.toLocaleTimeString());
            tempData.push(entry.temp ?? null);
            humData.push(entry.hum ?? null);
            vpdData.push(entry.vpd ?? null);
            fanData.push(entry.fan_speed ?? null);
          });

          if (labels.length === 0) {
            throw new Error("No valid data entries found");
          }

          // Обчислення діапазонів для кожної осі
          const tempRange = calculateAxisRange(tempData.filter((v) => v !== null));
          const humRange = calculateAxisRange(humData.filter((v) => v !== null));
          const vpdRange = calculateAxisRange(vpdData.filter((v) => v !== null));
          const fanRange = calculateAxisRange(fanData.filter((v) => v !== null));

          // Оновлення діапазонів осей
          sensorChart.options.scales["y-temp"].min = tempRange.min;
          sensorChart.options.scales["y-temp"].max = tempRange.max;
          sensorChart.options.scales["y-hum"].min = humRange.min;
          sensorChart.options.scales["y-hum"].max = humRange.max;
          sensorChart.options.scales["y-vpd"].min = vpdRange.min;
          sensorChart.options.scales["y-vpd"].max = vpdRange.max;
          sensorChart.options.scales["y-fan"].min = fanRange.min;
          sensorChart.options.scales["y-fan"].max = fanRange.max;

          // Оновлення графіка
          sensorChart.data.labels = labels;
          sensorChart.data.datasets[0].data = tempData;
          sensorChart.data.datasets[1].data = humData;
          sensorChart.data.datasets[2].data = vpdData;
          sensorChart.data.datasets[3].data = fanData;
          sensorChart.update();

          hideError();
        } catch (error) {
          console.error("Error fetching data:", error.message);
          showError("Failed to load data. Please try again later.");
        }
      }

      // Виклик функції для отримання даних при завантаженні сторінки
      fetchData();

      // Оновлення даних кожні 60 секунд
      setInterval(fetchData, 60000);
    </script>
  </body>
</html>
